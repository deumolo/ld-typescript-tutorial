// ESSENTIAL TYPESCRIPT

1.- En typescript, cuando se inicializa una variable, el tipo de variable que se use,
hará que esa variable solo acepte ese tipo durante todo el archivo.

2.- En caso de que una variable no tenga un valor inicial, se puede declarar el tipo sin un valor inicial.

Ejemplo:

    let testString: string;
    testString = "hello"

3.- Se pueden asignar multiples tipos a una variable, esto se hace con el simbolo de pipe (|):

Ejemplo:

    let stringOrNumber: string | number;
    let stringOrNumber: string | number = "hello";
    let stringOrNumber: stribong | number = 8;

4.- Se puede seguir este patrón de logica para asignar un tipo de valores en un arreglo.

Ejemplo:

    let names = ["John", "Sara", "Ana"];

Este arreglo solo aceptará valores de tipo string al momento de querer agregar nuevos elementos por medio de push.

5.- Para asignar el tipo a un array sin valores iniciales, se puede seguir este ejemplo:
    let testStringArray : string[];

6.- Para asignar multiples tipos de valores a un array se usa el siguiente ejemplo:
    let testStringOrNumberArray : (string | number)[];
    testStringOrNumberArray = ["hello", 8];

7.- Con objetos no es necesario declarar el tipo de variable, ya que se puede hacer de la siguiente manera:

    let testObject = {
        name: "John",
        age: 30
    }

Pero una vez que una propiedad X de un objeto Y es declarada, el tipo de variable de esa propiedad X no puede ser cambiado.

En el ejemplo, name siempre debe ser string y age siempre debe ser numero

8.- No se le puede agregar valores a una propiedad que no existe en un objeto, a menos que se declare el tipo de variable.

9.- Un objeto sin valores iniciales pero con tipos asignados solo puede llenarse completando todos los valores de las propiedades.

10.- Para declarar una propiedad opcional en un objeto, se usa el simbolo de interrogación (?).

Ejemplo:   
    let userObj2 : {
        username: string;
        age: number;
        isAdmin: boolean;
        phone?. number;
    }

11.- Este valor podría existir o no y no marcar una alerta.

12.- Se puede usar el tipo 'any' libremente, pero esta deja muy fuera las herramientas de typescript.

13.- Al no declarar un tipo en una variable, el default es 'any'

// FUNCTIONS 

14.- Con una función es igual, si se declara dentro de una variable o constante, este nombre solo se podrá usar con funciones

También si no se regresa nada y se había especificado un traceDeprecation, marcaría error.

15.- En una función se puede especificar el tipo de valor que va a regresar, como el siguiente ejemplo:

const addNumbers = (a: number, b: number): number => {
    return a + b;
}

16.- Al contrario del punto 14, si se asigna el valor tipo void a una función y esta regresa un valor,
el editor marcará error

17.- Para agregar un parametro opcional se usa el simbolo '?' de la siguiente manera:

const addNumbers = (a: number, b: number, another?:number): number => {
    return a + b;
} 

// TYPE ALIASES 

18.- Para crear un tipo de variable personalizado, se usa la palabra reservada 'type', esto sirve para funciones 
en las que la especificacion de tipos pude tomar un tamaño grande, en el siguiente ejemplo se usará para definir
el tipo de un objeto:

type UserType = {
    username: string;
    age: number;
    phone?: number;
}

let betterFunction = (user: UserType) => {
    console.log(user.username);
}

19.- Un caso raro pero que podía usarse es crear un function prototype, de la siguiente manera:

type printerFunc =  (a:number,b:number) => void

let write : printerFunc = (a,b) => {
    console.log(a + b);
}

De esta manera se pude especificar la manera de una función de constuirse y usarse para otras tareas

20.- Usando un valor de opción fija se pueden definir valores aceptados para una variable o propiedad de un objeto,
esto se hace de la siguiente manera:

type UserType2 = {
    username: string;
    age: number;
    phone?: number; 
    theme: "dark" | "light";
}

// INTERFACES

21.- En el caso de necesitar agregar propiedades a un type ya existente, se pueden usar interfaces,
ya que estas dan la opción de ser heredadas y extendidas, podemos usar el siguiente ejemplo:

interface IUser {
    username: string;
    age: number;
    phone?: number;
}

interface IEmployee extends IUser {
    salary: number;
    position: string;
}

const employee: IEmployee = {
    username: "John",
    age: 30,
    salary: 5000,
    position: "Developer"
}

// GENERICS

22.- Generics en typescript son plantillas de codigo que se pueden usar y reutilizar para seguir un patron de desarrollo
en nuestros archivos.

23.- En base al siguiente ejemplo de una interfaz que acepta un valor extra como un arreglo de objetos tipo IAuthor o ICategory

interface IPost {
    id: number;
    title: string;
    desc: string;
    extra: IAuthor[] | ICategory[];
}

Se puede refactorizar de la siguiente manera, declarando un tipo de variable generico, y declarando que el valor extra pueda
tomar cualquier tipo de valor.

interface IPostBetter<T> {
    id: number;
    title: string;
    desc: string;
    extra: T[];
}

Un ejemplo de implementacion de esta interfaz sería la siguiente:

const testMe: IPostBetter<String> = {
    id: 1,
    title: 'test',
    desc: 'test',
    extra: ['test', 'test2'],
};

24.- Para declarar un tipo de variable objeto para utilizarse de una interfaz se extiende el object en T:

interface IPostEvenBetter<T extends Object> {
    id: 1;
    title: 'test';
    desc: 'test';
    extra: T[];
}

Para implementar esta interfaz con el valor declarado como objeto se pueden tomar dos alternativas:

a) Se puede declarar la estructura del objeto manualmente:

const testMe2: IPostEvenBetter<{ id: number; username: string }> = {
    id: 1,
    title: 'test',
    desc: 'test',
    extra: [{ id: 1, username: 'test' }],
};

b) Se puede agregar una interfaz previamente creada :

const testMe3: IPostEvenBetter<IAuthor> = {
    id: 1,
    title: 'test',
    desc: 'test',
    extra: [{ id: 1, username: 'test' }],
};
